/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef, useState, useMemo } from 'react';
import { useAnimations, useFBX, useGLTF } from '@react-three/drei';
import { useControls } from "leva";
import { useFrame, useLoader } from '@react-three/fiber';

import * as THREE from 'three';

const corresponding = {
  A: "viseme_PP",
  B: "viseme_kk",
  C: "viseme_I",
  D: "viseme_AA",
  E: "viseme_O",
  F: "viseme_U",
  G: "viseme_FF",
  H: "viseme_TH",
  X: "viseme_PP",
};

export function Character(props) {


  const [playAudio, setPlayAudio] = useState(false);
  const morphTargetSmoothing = 0.3;
  const smoothMorphTarget = true;

  const [script, setScript] = useState("response");
  const [response, setResponse] = useState("Loading");
  const [audioUrl, setAudioUrl] = useState("None");

  const { nodes, materials } = useGLTF('/models/maleCharacter.glb');
  const audio = useMemo(() => new Audio(`/audios/${script}.mp3`), [script]);
  const jsonFile = useLoader(THREE.FileLoader, `/audios/${script}.json`);
  const lipsync = JSON.parse(jsonFile);

  const [isBlinking, setIsBlinking] = useState(false);
  const [blinkDuration, setBlinkDuration] = useState(0);
  const [blinkInterval, setBlinkInterval] = useState(0);
  const [nextBlinkTime, setNextBlinkTime] = useState(0);

  const [headPositionAtFrame0, setHeadPositionAtFrame0] = useState(null);
  const threshold = 0.06;

  const randomBlinkTime = () => Math.random() * 3 + 2;


  useEffect(() => {
    // Set an initial random blink interval
    setNextBlinkTime(randomBlinkTime());
  }, []);

  useEffect(() => {
    if (nodes.Wolf3D_Head) {
      setHeadPositionAtFrame0(nodes.Wolf3D_Head.position.clone()); // Save position at frame 0
    }
  }, [nodes]);

  useFrame((state) => {
    const currentAudioTime = audio.currentTime;
    if (nodes.EyeLeft && nodes.EyeRight && headPositionAtFrame0) {
      const currentTime = state.clock.getElapsedTime();

      const headObject = group.current.getObjectByName("Head");
      const headPosition = new THREE.Vector3();
      headObject.getWorldPosition(headPosition);

      const distance = headPosition.distanceTo(headPositionAtFrame0);

      if (distance < threshold && currentTime >= nextBlinkTime) {
        console.log(distance);
        setIsBlinking(true);
        setBlinkDuration(Math.random() * 0.17 + 0.1);
        setBlinkInterval(currentTime + blinkDuration);
        setNextBlinkTime(currentTime + randomBlinkTime());
      }

      if (isBlinking) {
        const progress = (currentTime - (blinkInterval - blinkDuration)) / blinkDuration;
        const blinkProgress = Math.min(progress, 1);
        const blinkValue = THREE.MathUtils.lerp(1, 0, blinkProgress);

        nodes.Wolf3D_Head.morphTargetInfluences[nodes.Wolf3D_Head.morphTargetDictionary["eyeBlinkRight"]] = blinkValue;
        nodes.Wolf3D_Head.morphTargetInfluences[nodes.Wolf3D_Head.morphTargetDictionary["eyeBlinkLeft"]] = blinkValue;

        if (progress >= 1) {
          setIsBlinking(false);
        }
      }
    }


    Object.values(corresponding).forEach((value) => {
      if (!smoothMorphTarget) {
        nodes.Wolf3D_Head.morphTargetInfluences[
          nodes.Wolf3D_Head.morphTargetDictionary[value]
        ] = 0;
        nodes.Wolf3D_Teeth.morphTargetInfluences[
          nodes.Wolf3D_Teeth.morphTargetDictionary[value]
        ] = 0;
      } else {
        nodes.Wolf3D_Head.morphTargetInfluences[
          nodes.Wolf3D_Head.morphTargetDictionary[value]
        ] = THREE.MathUtils.lerp(
          nodes.Wolf3D_Head.morphTargetInfluences[
          nodes.Wolf3D_Head.morphTargetDictionary[value]
          ],
          0,
          morphTargetSmoothing
        );

        nodes.Wolf3D_Teeth.morphTargetInfluences[
          nodes.Wolf3D_Teeth.morphTargetDictionary[value]
        ] = THREE.MathUtils.lerp(
          nodes.Wolf3D_Teeth.morphTargetInfluences[
          nodes.Wolf3D_Teeth.morphTargetDictionary[value]
          ],
          0,
          morphTargetSmoothing
        );
      }
    });

    for (let i = 0; i < lipsync.mouthCues.length; i++) {
      const mouthCue = lipsync.mouthCues[i];
      if (
        currentAudioTime >= mouthCue.start &&
        currentAudioTime <= mouthCue.end
      ) {
        if (!smoothMorphTarget) {
          nodes.Wolf3D_Head.morphTargetInfluences[
            nodes.Wolf3D_Head.morphTargetDictionary[
            corresponding[mouthCue.value]
            ]
          ] = 1;
          nodes.Wolf3D_Teeth.morphTargetInfluences[
            nodes.Wolf3D_Teeth.morphTargetDictionary[
            corresponding[mouthCue.value]
            ]
          ] = 1;
        } else {
          nodes.Wolf3D_Head.morphTargetInfluences[
            nodes.Wolf3D_Head.morphTargetDictionary[
            corresponding[mouthCue.value]
            ]
          ] = THREE.MathUtils.lerp(
            nodes.Wolf3D_Head.morphTargetInfluences[
            nodes.Wolf3D_Head.morphTargetDictionary[
            corresponding[mouthCue.value]
            ]
            ],
            1,
            morphTargetSmoothing
          );
          nodes.Wolf3D_Teeth.morphTargetInfluences[
            nodes.Wolf3D_Teeth.morphTargetDictionary[
            corresponding[mouthCue.value]
            ]
          ] = THREE.MathUtils.lerp(
            nodes.Wolf3D_Teeth.morphTargetInfluences[
            nodes.Wolf3D_Teeth.morphTargetDictionary[
            corresponding[mouthCue.value]
            ]
            ],
            1,
            morphTargetSmoothing
          );
        }

        break;
      }
    }
  });

  useEffect(() => {
    if (playAudio) {
      audio.play();
    } else {
      setAnimation("Idle");
      audio.pause();
    }
  }, [playAudio, script]);


  const { animations: idleAnimation } = useFBX("/animations/idle.fbx");
  const { animations: nodeAnimation } = useFBX("/animations/nodeHead.fbx");

  idleAnimation[0].name = "Idle";
  nodeAnimation[0].name = "Node";

  const [animation, setAnimation] = useState("Idle");

  const group = useRef();
  const { actions } = useAnimations([idleAnimation[0], nodeAnimation[0]], group);

  useEffect(() => {
    if (actions[animation]) {
      if (!actions[animation].isRunning()) {
        actions[animation].reset().play();
      }
    }
    return () => {
      if (actions[animation]) {
        actions[animation].fadeOut(0.5);
      }
    };
  }, [animation, actions]);

  useEffect(() => {
    if (!playAudio) {
      // If audio is paused, set animation to Idle without affecting the current animation
      if (animation !== "Idle") {
        setAnimation("Idle");
      }
    }
  }, [playAudio, animation]);

  useFrame((state) => {
    if (headFollow) {
      group.current.getObjectByName("Head").lookAt(state.camera.position);
    }
  });

  return (
    <group {...props} dispose={null} ref={group}>
      <primitive object={nodes.Hips} />
      <skinnedMesh
        name="EyeLeft"
        geometry={nodes.EyeLeft.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeLeft.skeleton}
        morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}
      />
      <skinnedMesh
        name="EyeRight"
        geometry={nodes.EyeRight.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeRight.skeleton}
        morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Head"
        geometry={nodes.Wolf3D_Head.geometry}
        material={materials.Wolf3D_Skin}
        skeleton={nodes.Wolf3D_Head.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Teeth"
        geometry={nodes.Wolf3D_Teeth.geometry}
        material={materials.Wolf3D_Teeth}
        skeleton={nodes.Wolf3D_Teeth.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Hair.geometry}
        material={materials.Wolf3D_Hair}
        skeleton={nodes.Wolf3D_Hair.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Body.geometry}
        material={materials.Wolf3D_Body}
        skeleton={nodes.Wolf3D_Body.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Bottom.geometry}
        material={materials.Wolf3D_Outfit_Bottom}
        skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Footwear.geometry}
        material={materials.Wolf3D_Outfit_Footwear}
        skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton}
      />
      <skinnedMesh
        geometry={nodes.Wolf3D_Outfit_Top.geometry}
        material={materials.Wolf3D_Outfit_Top}
        skeleton={nodes.Wolf3D_Outfit_Top.skeleton}
      />
    </group>
  )
}

useGLTF.preload('/models/maleCharacter.glb')
